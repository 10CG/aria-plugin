---
name: brainstorm
description: |
  AI-DDD 头脑风暴引擎，通过多轮对话澄清需求、记录设计决策、生成结构化输出。
  支持问题空间探索、需求分解、技术方案设计三层模式。

  使用场景："我要做个新功能"、"如何设计这个功能"、"讨论技术方案"

argument-hint: "[mode] [topic]"
disable-model-invocation: false
user-invocable: true
allowed-tools: Read, Glob, Grep, Bash, AskUserQuestion
---

# 头脑风暴引擎 (Brainstorm v1.0)

> **版本**: 1.0.0 | **角色**: AI-DDD 协作思考的核心载体

---

## 快速开始

### 我应该使用这个 Skill 吗？

**使用场景**:
- 需求还不清晰，需要多轮讨论澄清
- 需要记录设计决策和"为什么"的思考过程
- 需要在多个方案之间做选择
- 需要探索问题的本质而非急于实现

**不使用场景**:
- 需求明确，直接进入实现 → 使用 `phase-b-developer`
- 简单 bug 修复 → 使用 `quick-fix`
- 只需要生成文档 → 使用 `spec-drafter`

---

## 核心功能

| 功能 | 描述 |
|------|------|
| **智能引导对话** | 根据输入模糊度选择引导策略，防止过早收敛 |
| **决策记录** | 结构化记录"为什么选 A 而非 B"，可追溯 |
| **约束管理** | 收集并验证业务/技术/团队约束 |
| **方案对比** | 多维度方案分析，量化对比 |
| **领域建模** | 统一业务术语，识别领域边界 |
| **输出同步** | 自动生成 OpenSpec/PRD 草案 |

---

## 工作模式

### Mode 1: problem (问题空间探索)

```yaml
触发条件:
  - 用户输入模糊 ("我想做个...")
  - state-scanner 检测到新功能想法
  - 复杂度未知的需求

目标:
  - 澄清问题的本质
  - 区分真需求 vs 伪需求
  - 定义业务目标
  - 识别约束条件

输出:
  - problem-definition.md
  - 决策: 是否需要 PRD
```

### Mode 2: requirements (需求分解)

```yaml
触发条件:
  - PRD 创建时
  - PRD 细化时
  - 功能优先级讨论

目标:
  - 分解功能为 User Stories
  - 确定优先级
  - 识别依赖关系
  - 估算复杂度

输出:
  - user-stories/US-*.md (多个)
  - 优先级矩阵
```

### Mode 3: technical (技术方案设计)

```yaml
触发条件:
  - OpenSpec 创建前
  - 架构选型讨论
  - 技术难点攻关

目标:
  - 设计技术方案
  - 技术选型
  - 风险评估
  - 生成 OpenSpec 草案

输出:
  - decision-log.md
  - openspec/changes/proposal.md (草案)
```

---

## 执行流程

### 阶段 1: 初始化

```yaml
步骤 1: 模式检测
  输入分析:
    - 用户意图识别
    - 模糊度评估 (0-1)
    - 复杂度预估 (Level1/2/3)

  决策:
    - 高模糊度 → problem 模式
    - 中模糊度 + 有 PRD → requirements 模式
    - 低模糊度 + 有 US → technical 模式

步骤 2: 上下文加载
  检查内容:
    - 是否有现有 PRD?
    - 是否有相关 OpenSpec?
    - 是否有决策历史?
    - 项目约束配置?

步骤 3: 引导策略选择
  选择模板:
    - 开放探索型 (problem 模式)
    - 结构化分解型 (requirements 模式)
    - 方案对比型 (technical 模式)
```

### 阶段 2: 对话引导

#### 对话状态机

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          对话状态机                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [INIT] → [CLARIFY] → [EXPLORE] → [CONVERGE] → [SUMMARY]                │
│     │         │           │            │              │                │
│     │         ↓           ↓            ↓              ↓                │
│     │    澄清术语     探索选项      评估方案      总结决策              │
│     │    统一概念     分析约束      对比优劣      记录理由              │
│     │                                                     │            │
│     └─────────────────────────────────────────────────────┘            │
│                           │                                              │
│                           ↓ 检测共识形成或达到最大轮次                   │
│                      [COMPLETE]                                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 引导策略矩阵

| 状态 | 目标 | 提问策略 | 示例问题 |
|------|------|----------|----------|
| **CLARIFY** | 统一术语 | 定义式提问 | "你说的 X 具体指什么？" |
| **EXPLORE** | 探索选项 | 开放式提问 | "我们有哪些实现方式？" |
| **CONVERGE** | 收敛方案 | 对比式提问 | "方案 A 和 B 的权衡是？" |
| **SUMMARY** | 确认决策 | 确认式提问 | "所以我们决定采用...，对吗？" |

#### 深度控制

```yaml
对话深度指标:
  fuzziness: 输入模糊度 (0=清晰, 1=非常模糊)
  coverage: 讨论覆盖面 (0-1)
  consensus: 共识程度 (0=分歧, 1=一致)
  constraints_verified: 约束验证状态

深度阈值:
  shallow: coverage < 0.5 → 继续探索
  adequate: coverage >= 0.5 && consensus >= 0.7 → 可以收敛
  deep: coverage >= 0.7 && consensus >= 0.8 → 应该收敛

最大轮次:
  problem: 10 轮
  requirements: 15 轮
  technical: 8 轮
```

### 阶段 3: 决策记录

#### 决策点识别

```yaml
触发条件:
  - 用户明确选择 ("我选择方案 A")
  - 共识度 >= 0.8
  - 达到最大轮次且唯一可行方案

记录内容:
  必需:
    - 决策 ID
    - 决策描述
    - 选择的方案
    - 决策理由
    - 做出时间

  可选:
    - 被拒绝的方案及理由
    - 假设条件
    - 可撤销性评估
    - 有效期
```

#### 决策日志格式

```markdown
## 决策: DEC-001 - AI 客服技术方案

**日期**: 2026-02-05
**状态**: Active
**可撤销**: 是 (v2.0 前)

### 背景
需要为产品添加智能客服功能，用户期望 24/7 可用。

### 考虑的方案

| 方案 | 描述 | 优点 | 缺点 | 评分 |
|------|------|------|------|------|
| A | OpenAI API | 快速上线 | 数据出境 | ❌ |
| B | 自建 RAG | 私有化 | 维护成本 | ✅ |
| C | 混合方案 | 灵活 | 复杂 | 备选 |

### 最终选择
**方案 B**: 自建 RAG (FAISS + 本地模型)

### 理由
1. 满足合规要求 (数据不出境)
2. 成本可控 (< $500/月)
3. 满足初期性能需求

### 假设条件
- 初期 QPS < 100
- 文档总量 < 10万条
- 团队有能力维护

### 风险缓解
- 预留迁移到向量数据库的接口
- 定期评估托管服务选项
```

### 阶段 4: 输出生成

#### 输出映射

```yaml
problem 模式输出:
  主要:
    - docs/decisions/problem-{id}.md
  可选:
    - 触发 spec-drafter (创建 PRD)

requirements 模式输出:
  主要:
    - docs/decisions/requirements-{id}.md
    - docs/requirements/user-stories/US-*.md
  可选:
    - 更新 PRD

technical 模式输出:
  主要:
    - docs/decisions/technical-{id}.md
  可选:
    - openspec/changes/proposal.md (自动填充)
    - 触发 spec-drafter
```

---

## 引导模板

### 模板 1: 问题澄清 (problem 模式)

```yaml
开场:
  "让我们先理解一下你想要解决的问题。"

问题序列:
  1. 问题本质:
     "你描述的需求背后，核心问题是什么？"

  2. 受益人群:
     "谁会从这个功能中受益？"

  3. 成功标准:
     "怎么判断这个功能是否成功？"

  4. 约束条件:
     "有什么限制需要考虑？(预算/时间/技术)"

收敛信号:
  - 能用一句话描述问题
  - 能明确受益人
  - 有可衡量的成功标准
```

### 模板 2: 需求分解 (requirements 模式)

```yaml
开场:
  "让我们把这个需求分解成可实现的 User Stories。"

问题序列:
  1. 功能拆解:
     "这个功能可以分解为哪些子功能？"

  2. 用户场景:
     "用户在什么情况下会使用这个功能？"

  3. 优先级:
     "如果只能做一部分，先做哪个？"

  4. 依赖关系:
     "这些功能之间有依赖吗？"

收敛信号:
  - 每个 Story 独立可测试
  - 优先级明确
  - 依赖关系清晰
```

### 模板 3: 方案对比 (technical 模式)

```yaml
开场:
  "让我们讨论一下实现方案。"

问题序列:
  1. 方案列举:
     "实现这个功能有哪些技术选项？"

  2. 约束检查:
     "根据 [约束条件]，哪些方案不可行？"

  3. 优缺点对比:
     "在可行方案中，各有什么优缺点？"

  4. 风险评估:
     "每个方案的主要风险是什么？"

  5. 决策:
     "综合考虑，你倾向哪个方案？"

收敛信号:
  - 排除不可行方案
  - 可行方案有明确对比
  - 风险已识别
  - 做出明确选择
```

---

## 约束管理

### 约束分类

```yaml
business_constraints:
  - budget: 预算限制
  - timeline: 时间限制
  - compliance: 合规要求 (GDPR, 数据安全)
  - resources: 人力/资源限制

technical_constraints:
  - architecture: 架构约束 (微服务/单体)
  - tech_stack: 技术栈限制
  - performance: 性能要求 (延迟/吞吐)
  - scalability: 扩展性要求
  - compatibility: 兼容性要求

team_constraints:
  - skills: 团队技能
  - preferences: 团队偏好
  - capacity: 可用工时
  - communication: 协作方式
```

### 约束验证流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         约束验证流程                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 收集约束                                                             │
│     ├── 从项目配置读取默认约束                                           │
│     └── 对话中收集特定约束                                               │
│                                                                         │
│  2. 方案过滤                                                             │
│     ├── 检查每个方案是否违反硬约束                                       │
│     └── 标记不可行方案                                                   │
│                                                                         │
│  3. 风险评估                                                             │
│     ├── 评估软约束的影响程度                                             │
│     └── 提出缓解措施                                                     │
│                                                                         │
│  4. 记录决策                                                             │
│     ├── 记录约束条件                                                     │
│     └── 记录约束导致的选择                                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 与其他 Skills 的集成

### 集成点 1: state-scanner

```yaml
触发条件:
  - 检测到模糊需求意图
  - 变更复杂度 >= Level 2
  - 无对应 OpenSpec

推荐输出:
  "发现新功能想法，建议先进行头脑风暴澄清需求"
  选项:
    [1] 开始头脑风暴
    [2] 直接创建 OpenSpec
    [3] 跳过，稍后处理
```

### 集成点 2: spec-drafter

```yaml
输入:
  - 来自 brainstorm 的决策记录
  - 约束条件
  - 方案选择

行为:
  - 自动填充 proposal.md 的背景部分
  - 预填充技术方案
  - 引用决策 ID

输出示例:
  ```markdown
  # Proposal: AI 客服功能

  > **决策来源**: [DEC-001](../../decisions/technical-001.md)

  ## 背景
  (来自 problem-brainstorm 的问题定义)

  ## 技术方案
  (来自 technical-brainstorm 的方案选择)
  ```
```

### 集成点 3: requirements-validator

```yaml
验证内容:
  - User Story 与决策记录的一致性
  - 约束条件是否被违反
  - 优先级与决策逻辑的一致性

错误示例:
  "❌ US-003 描述使用了 OpenAI API，但 DEC-001 决策排除数据出境方案"
```

### 集成点 4: task-planner

```yaml
输入增强:
  - 来自 technical-brainstorm 的技术方案
  - 更准确的任务分解
  - 更好的依赖关系识别

输出改进:
  - 任务关联决策 ID
  - 风险任务标记
```

---

## 配置选项

### 项目级配置

```yaml
# .claude/aria.local.md

brainstorm:
  # 是否启用
  enabled: true

  # 触发模式
  trigger_mode: auto  # auto | always | manual

  # 自动触发阈值
  auto_trigger:
    fuzziness_threshold: 0.6  # 模糊度超过此值自动触发
    complexity_threshold: Level2  # Level2+ 自动触发

  # 对话配置
  conversation:
    max_rounds:
      problem: 10
      requirements: 15
      technical: 8

    convergence_threshold: 0.7  # 共识度超过此值可以收敛

  # 输出配置
  output:
    save_decisions: true
    save_conversation: false  # 是否保存完整对话
    decision_dir: docs/decisions/
    auto_sync_openspec: true

  # 默认约束
  default_constraints:
    budget: "$1000/月"
    compliance: ["GDPR", "数据不出境"]
```

### 会话级配置

```yaml
# 通过参数传递

/brainstorm problem "添加AI功能"
  --fuzziness high
  --max-rounds 15
  --constraints budget:$500

/brainstorm technical
  --mode interactive
  --auto-converge false
```

---

## 使用示例

### 示例 1: Problem 模式完整对话

```yaml
用户: /brainstorm problem "我想给应用加个AI功能"

AI: 让我们先理解一下你想要解决的问题。

     [问题澄清]
     1. 你说的 AI 功能具体指什么？
      - a) 智能推荐
      - b) 自动补全
      - c) 对话助手
      - d) 其他

用户: c，我想做一个智能客服

AI: 明白了，智能客服助手。让我们继续澄清：

     2. 这个客服要解决什么问题？
      - 当前有什么痛点？
      - 期望达到什么效果？

用户: 现在客服经常不在，用户问题得不到及时回答。
     我希望用户能随时得到帮助。

AI: [记录问题核心: 及时性]

     3. 关于回答质量:
      - 需要多"智能"？
      - 简单 FAQ 自动回答够吗？
      - 还是需要理解复杂问题？

用户: 至少能回答产品相关的问题，复杂问题再转人工。

AI: [记录约束: 产品知识库 + 人工兜底]

     4. 有什么限制条件吗？
      - 预算范围？
      - 时间要求？
      - 合规要求？

用户: 预算有限，最好每月不超过500块。
     数据不能出私有机房，有合规要求。

AI: [记录约束: 预算<$500 + 私有化部署]

     让我总结一下我们的讨论:

     ╔═══════════════════════════════════════════════════════════╗
     ║                     问题定义                               ║
     ╠═══════════════════════════════════════════════════════════╣
     ║ 核心问题: 用户咨询得不到及时响应                           ║
     ║ 目标用户: 产品使用用户                                     ║
     ║ 成功标准: 24/7 可用，产品问题自动回答率 > 80%              ║
     ╠═══════════════════════════════════════════════════════════╣
     ║ 约束条件:                                                  ║
     ║ - 预算: < $500/月                                         ║
     ║ - 部署: 私有化，数据不出境                                 ║
     ║ - 功能: 产品知识库问答，复杂问题转人工                     ║
     ╚═══════════════════════════════════════════════════════════╝

     建议: 创建 PRD 来详细规划这个功能。

     下一步:
     [1] 继续头脑风暴，分解 User Stories
     [2] 创建 PRD 文档
     [3] 记录决策，稍后继续

用户: 1

AI: [切换到 requirements 模式]
     让我们把智能客服分解成具体的 User Stories...
```

### 示例 2: Technical 模式快速对话

```yaml
用户: /brainstorm technical "RAG 实现，选择向量数据库"

AI: [加载上下文: US-001 AI 客服基础问答]

     已知约束:
     - 预算: < $500/月
     - 部署: 私有化

     可行的向量存储选项:

     | 方案 | 类型 | 月成本 | 优点 | 缺点 |
     |------|------|--------|------|------|
     | A | Pinecone | $70 | 易用 | 需外网 |
     | B | Weaviate | 自建 | 免费 | 运维成本 |
     | C | FAISS | 嵌入 | $0 | 功能有限 |
     | D | Milvus | 自建 | 免费 | 复杂度高 |

     考虑到[数据不出境]约束，排除 A。

     在 B/C/D 之间，你的数据量级大概是多少？

用户: 文档大概 1 万条，预期月增长 1000 条

AI: 这个规模下，C(FAISS) 最合适:
     - 完全免费，满足预算要求
     - 1万条文档性能良好
     - Python 生态支持完善

     但要考虑:
     - 持续增长需要定期评估迁移时机
     - 需要自己实现增量更新逻辑

     是否选择 FAISS？如果需要更强大的功能，
     我建议 Milvus 作为备选。

用户: 就用 FAISS 吧

AI: [记录决策 DEC-002]

     决策记录:
     - 方案: FAISS 向量存储
     - 理由: 满足成本 + 性能要求
     - 假设: 文档量 < 5 万条时可行
     - 风险: 增量更新需自行实现
     - 缓解: 预留迁移接口，定期评估

     已自动更新 OpenSpec proposal.md。

     下一步:
     [1] 继续讨论嵌入模型选择
     [2] 生成完整技术方案
     [3] 结束头脑风暴

用户: 1

AI: [继续对话]
```

---

## 输出文件规范

### 决策日志结构

```
docs/decisions/
├── .template.md           # 决策记录模板
├── problem-001.md         # 问题空间探索决策
├── requirements-001.md    # 需求分解决策
└── technical-001.md       # 技术方案决策
```

### 文件命名

```yaml
格式: {mode}-{sequence}.md

示例:
  problem-001.md  → 问题空间探索，第 1 个决策
  tech-003.md    → 技术方案，第 3 个决策
```

### 最小决策模板

```markdown
# 决策: DEC-{id} - {title}

> **日期**: {{date}}
> **模式**: {{problem|requirements|technical}}
> **状态**: Active | Archived | Superseded

## 背景

{{决策的背景和上下文}}

## 约束条件

| 类型 | 约束 | 影响 |
|------|------|------|
| | | |

## 考虑的方案

### 方案 A: {{name}}

**描述**:
**优点**:
**缺点**:
**评分**:

### 方案 B: {{name}}

...

## 最终选择

**方案**: {{selected}}

## 理由

{{为什么选择这个方案}}

## 假设条件

{{决策基于的假设}}

## 风险与缓解

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| | | | |

## 变更历史

| 日期 | 变更 | 原因 |
|------|------|------|
```

---

## 检查清单

### 使用前

- [ ] 有需要澄清的需求或想法
- [ ] 愿意进行多轮对话
- [ ] 准备记录决策

### 使用中

- [ ] 核心问题已澄清
- [ ] 约束条件已收集
- [ ] 方案已充分讨论
- [ ] 决策理由已记录

### 使用后

- [ ] 决策日志已创建
- [ ] 后续步骤已明确
- [ ] 相关文档已同步

---

## 错误处理

| 错误 | 原因 | 解决方案 |
|------|------|----------|
| 对话无法收敛 | 问题过于复杂或模糊 | 建议分解为多个子问题 |
| 约束冲突 | 约束条件互相矛盾 | 提示用户放宽约束 |
| 无可行方案 | 所有方案都被排除 | 重新评估约束或寻找新方案 |
| 用户放弃 | 用户不想继续讨论 | 保存当前讨论记录，稍后继续 |

---

## 相关文档

- [SKILL_DESIGN.md](./SKILL_DESIGN.md) - 设计文档
- [state-scanner](../state-scanner/SKILL.md) - 状态扫描入口
- [spec-drafter](../spec-drafter/SKILL.md) - 规范创建
- [requirements-validator](../requirements-validator/SKILL.md) - 需求验证

---

**最后更新**: 2026-02-05
**Skill版本**: 1.0.0
