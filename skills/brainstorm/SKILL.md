---
name: brainstorm
description: |
  AI-DDD 头脑风暴引擎，通过多轮对话澄清需求、记录设计决策、生成结构化输出。
  支持问题空间探索、需求分解、技术方案设计三层模式。

  使用场景："我要做个新功能"、"如何设计这个功能"、"讨论技术方案"

argument-hint: "[mode] [topic]"
disable-model-invocation: false
user-invocable: true
allowed-tools: Read, Glob, Grep, Bash, AskUserQuestion
---

# 头脑风暴引擎 (Brainstorm v1.0)

> **版本**: 1.1.0 | **角色**: AI-DDD 协作思考的核心载体
> **Phase 1**: 核心框架已实现 (状态机/问题生成/深度控制/决策记录/约束管理)

---

## 快速开始

### 我应该使用这个 Skill 吗？

**使用场景**:
- 需求还不清晰，需要多轮讨论澄清
- 需要记录设计决策和"为什么"的思考过程
- 需要在多个方案之间做选择
- 需要探索问题的本质而非急于实现

**不使用场景**:
- 需求明确，直接进入实现 → 使用 `phase-b-developer`
- 简单 bug 修复 → 使用 `quick-fix`
- 只需要生成文档 → 使用 `spec-drafter`

---

## 核心功能

| 功能 | 描述 |
|------|------|
| **智能引导对话** | 根据输入模糊度选择引导策略，防止过早收敛 |
| **决策记录** | 结构化记录"为什么选 A 而非 B"，可追溯 |
| **约束管理** | 收集并验证业务/技术/团队约束 |
| **方案对比** | 多维度方案分析，量化对比 |
| **领域建模** | 统一业务术语，识别领域边界 |
| **输出同步** | 自动生成 OpenSpec/PRD 草案 |

---

## 工作模式

### Mode 1: problem (问题空间探索)

```yaml
触发条件:
  - 用户输入模糊 ("我想做个...")
  - state-scanner 检测到新功能想法
  - 复杂度未知的需求

目标:
  - 澄清问题的本质
  - 区分真需求 vs 伪需求
  - 定义业务目标
  - 识别约束条件

输出:
  - problem-definition.md
  - 决策: 是否需要 PRD
```

### Mode 2: requirements (需求分解)

```yaml
触发条件:
  - PRD 创建时
  - PRD 细化时
  - 功能优先级讨论

目标:
  - 分解功能为 User Stories
  - 确定优先级
  - 识别依赖关系
  - 估算复杂度

输出:
  - user-stories/US-*.md (多个)
  - 优先级矩阵
```

### Mode 3: technical (技术方案设计)

```yaml
触发条件:
  - OpenSpec 创建前
  - 架构选型讨论
  - 技术难点攻关

目标:
  - 设计技术方案
  - 技术选型
  - 风险评估
  - 生成 OpenSpec 草案

输出:
  - decision-log.md
  - openspec/changes/proposal.md (草案)
```

---

## 执行流程

### 阶段 1: 初始化

```yaml
步骤 1: 模式检测
  输入分析:
    - 用户意图识别
    - 模糊度评估 (0-1)
    - 复杂度预估 (Level1/2/3)

  决策:
    - 高模糊度 (>=0.6) → problem 模式
    - 中模糊度 (0.3-0.6) + 有 PRD → requirements 模式
    - 低模糊度 (<0.3) + 有 US → technical 模式

步骤 2: 上下文加载
  检查内容:
    - 是否有现有 PRD? (docs/requirements/prd-*.md)
    - 是否有相关 OpenSpec? (openspec/changes/**/)
    - 是否有决策历史? (docs/decisions/*.md)
    - 项目约束配置? (.claude/aria.local.md)

步骤 3: 引导策略选择
  选择模板:
    - 开放探索型 (problem 模式)
    - 结构化分解型 (requirements 模式)
    - 方案对比型 (technical 模式)
```

---

### 阶段 2: 对话引导 (核心框架)

#### 2.1 对话状态机 (详细定义)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          对话状态机 (v1.0)                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│                         ╔═══════════════════╗                           │
│                         ▼     INIT          │                           │
│                    ┌──────────────┐         │                           │
│                    │ 模式检测      │         │                           │
│                    │ 上下文加载    │         │                           │
│                    │ 输出开场问题  │         │                           │
│                    └──────┬───────┘         │                           │
│                           │ 用户首次响应     │                           │
│                           ▼                  │                           │
│                    ╔═══════════════════╗     │                           │
│                    ▼    CLARIFY        │     │                           │
│               ┌──────────────┐         │     │                           │
│               │ 识别模糊术语  │         │     │                           │
│               │ 请求定义      │         │     │                           │
│               │ 建立术语表    │         │     │                           │
│               └──────┬───────┘         │     │                           │
│                      │ 关键术语已定义   │     │                           │
│                      ▼                  │     │                           │
│               ╔═══════════════════╗     │     │                           │
│               ▼    EXPLORE        │     │     │                           │
│          ┌──────────────┐         │     │     │                           │
│          │ 列举可能方案  │         │     │     │                           │
│          │ 收集约束条件  │         │     │     │                           │
│          │ 过滤不可行方案│         │     │     │                           │
│          └──────┬───────┘         │     │     │                           │
│                 │ 可行方案已明确   │     │     │                           │
│                 ▼                  │     │     │                           │
│          ╔═══════════════════╗     │     │     │                           │
│          ▼    CONVERGE        │     │     │     │                           │
│     ┌──────────────┐         │     │     │     │                           │
│     │ 多维度方案对比│         │     │     │     │                           │
│     │ 风险评估      │         │     │     │     │                           │
│     │ 引导决策      │         │     │     │     │                           │
│     └──────┬───────┘         │     │     │     │                           │
│            │ 明确选择/共识    │     │     │     │                           │
│            ▼                  │     │     │     │                           │
│     ╔═══════════════════╗     │     │     │     │                           │
│     ▼    SUMMARY        │     │     │     │     │                           │
│┌──────────────┐         │     │     │     │     │                           │
││ 总结讨论要点  │         │     │     │     │     │                           │
││ 生成决策记录  │         │     │     │     │     │                           │
││ 确认下一步    │         │     │     │     │     │                           │
│└──────┬───────┘         │     │     │     │     │                           │
│       │ 用户确认         │     │     │     │     │                           │
│       ▼                  │     │     │     │     │                           │
│ ╔═══════════════════╗    │     │     │     │     │                           │
│ ▼    COMPLETE       │    │     │     │     │     │                           │
│ 写入决策日志         │    │     │     │     │     │                           │
│ 同步相关文档         │    │     │     │     │     │                           │
│ 提供后续建议         │    │     │     │     │     │                           │
│ └───────────────────┘    │     │     │     │     │                           │
│                           │     │     │     │     │                           │
│                           │     │     │     │     │                           │
│                    ╚═══════════════════╝     │                           │
│                    用户明确选择              │                           │
│                    可提前跳转 ───────────────┘                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.2 状态转换规则 (可执行指令)

```yaml
# === 状态: INIT ===
INIT:
  entry:
    - 分析用户输入，确定模式 (problem/requirements/technical)
    - 从项目配置加载默认约束 (.claude/aria.local.md)
    - 扫描现有决策记录 (docs/decisions/)
    - 选择对应模式的引导模板
    - 输出开场问题
  exit_condition: 用户首次响应
  next_state: CLARIFY

  # 开场问题生成 (根据模式)
  opening_questions:
    problem:
      - "让我们先理解一下你想要解决的问题。"
      - "能详细描述一下你的想法吗？"

    requirements:
      - "让我们把这个需求分解成可实现的 User Stories。"
      - "首先，要实现的核心功能是什么？"

    technical:
      - "让我们讨论一下技术实现方案。"
      - "有哪些技术选项需要考虑？"

# === 状态: CLARIFY ===
CLARIFY:
  entry:
    - 从用户输入中提取可能模糊的术语
    - 识别业务术语、技术术语、缩写
    - 请求定义关键术语
  actions:
    - 术语澄清: "你说的 [X] 具体指什么？"
    - 概念统一: "所以 [X] 的定义是..."
    - 边界界定: "这个需求的边界在哪里？"
  exit_condition:
    - 关键术语已定义 >= 3 个
    - 或达到最大问题数 (3个)
  next_state: EXPLORE

# === 状态: EXPLORE ===
EXPLORE:
  entry:
    - 列举所有可能的方案/选项
    - 收集约束条件
    - 检查约束库 (.claude/aria.local.md)
  actions:
    - 方案列举: "实现 [X] 有哪些方式？"
    - 约束收集: "有什么限制条件？(预算/时间/技术)"
    - 约束验证: 对每个方案检查是否违反约束
    - 方案过滤: 标记不可行方案
  exit_condition:
    - 可行方案已明确 >= 2 个
    - 或达到最大问题数 (5个)
  next_state: CONVERGE

# === 状态: CONVERGE ===
CONVERGE:
  entry:
    - 创建方案对比表
    - 评估每个方案的优缺点
    - 计算方案评分 (基于约束匹配度)
  actions:
    - 对比分析: "方案 A 和 B 的主要区别是什么？"
    - 风险评估: "每个方案的主要风险是什么？"
    - 决策引导: "综合考虑，你倾向哪个方案？"
  exit_condition:
    - 用户明确选择 ("我选择方案A")
    - 或共识度 >= 0.8
    - 或达到最大问题数 (3个)
  next_state: SUMMARY

# === 状态: SUMMARY ===
SUMMARY:
  entry:
    - 总结讨论要点
    - 列出所有收集的约束
    - 确认最终选择
    - 生成决策记录草稿
  actions:
    - 总结确认: "所以我们决定采用...，对吗？"
    - 约束回顾: "我们的约束是..."
    - 决策确认: "这个决策的理由是..."
  exit_condition: 用户确认总结
  next_state: COMPLETE

# === 状态: COMPLETE ===
COMPLETE:
  entry:
    - 写入决策日志 (docs/decisions/)
    - 使用 decision-template.md 生成格式化记录
    - 生成决策 ID (DEC-YYYYMMDD-序号)
    - 更新决策索引
  actions:
    - 写入文件: 使用 Write 工具创建决策文档
    - 同步文档: 如需要，触发 spec-drafter
    - 提供后续建议
  output:
    - 决策记录路径
    - 后续步骤选项
```

#### 2.3 引导策略矩阵

| 状态 | 目标 | 提问策略 | 提示词模板 |
|------|------|----------|-----------|
| **CLARIFY** | 统一术语 | 定义式提问 | "你说的 {术语} 具体指什么？能举个例子吗？" |
| **EXPLORE** | 探索选项 | 开放式提问 | "实现 {目标} 有哪些可能的方式？有没有考虑过..." |
| **CONVERGE** | 收敛方案 | 对比式提问 | "方案 {A} 和 {B} 在 {维度} 上的权衡是什么？" |
| **SUMMARY** | 确认决策 | 确认式提问 | "所以综合来看，我们选择 {方案}，理由是 {理由}，对吗？" |

---

#### 2.4 深度控制逻辑

```yaml
# === 深度计算 ===
depth_metrics:
  fuzziness:
    description: 输入模糊度 (0=清晰, 1=非常模糊)
    calculation:
      - 术语模糊度: 未定义术语数 / 总术语数
      - 约束模糊度: 未指定约束数 / 预期约束数
      - 范围模糊度: 边界不明确的程度
    formula: "(术语模糊度 + 约束模糊度 + 范围模糊度) / 3"

  coverage:
    description: 讨论覆盖面 (0-1)
    calculation:
      - 话题覆盖: 已讨论话题数 / 预期话题数
      - 角度覆盖: 业务/技术/用户/运维 等角度
      - 约束覆盖: 已验证约束数 / 总约束数
    formula: "(话题 + 角度 + 约束) / 3"

  consensus:
    description: 共识程度 (0=分歧, 1=一致)
    calculation:
      - 用户明确选择: +0.5
      - 方案对比收敛: +0.3
      - 约束导致唯一解: +0.2
    formula: "min(1.0, 各项之和)"

# === 深度阈值 ===
depth_thresholds:
  shallow:
    condition: "coverage < 0.5"
    action: "继续探索，不收敛"
    guidance: "我们还需要了解更多信息才能做决策。"

  adequate:
    condition: "coverage >= 0.5 && consensus >= 0.5"
    action: "可以开始收敛"
    guidance: "信息基本充分，可以开始对比方案了。"

  deep:
    condition: "coverage >= 0.7 && consensus >= 0.7"
    action: "应该收敛"
    guidance: "我们已经讨论得足够充分了，建议现在做决策。"

  force_converge:
    condition: "round >= max_rounds * 0.8"
    action: "强制收敛"
    guidance: "为了效率，我们需要在接下来几轮内做出决策。"

# === 收敛检测 ===
convergence_detection:
  检查项:
    1. 用户明确选择:
       模式: "我选择|决定用|就用|采用"
       权重: 1.0 (直接触发收敛)

    2. 高共识度:
       条件: consensus >= 0.7
       权重: 0.8

    3. 轮次接近上限:
       条件: round >= max_rounds * 0.8
       权重: 0.6 (强制收敛)

    4. 约束导致唯一解:
       条件: feasible_options == 1
       权重: 0.9

  收敛决策:
    - 任一检查项权重 >= 0.8 → 触发收敛
    - 多项检查项权重之和 >= 1.0 → 触发收敛
    - 否则 → 继续当前状态

# === 最大轮次配置 ===
max_rounds:
  problem: 10
  requirements: 15
  technical: 8

  每状态问题上限:
    CLARIFY: 3
    EXPLORE: 5
    CONVERGE: 3
```

---

#### 2.5 决策记录工作流

```yaml
# === 决策点识别 ===
decision_recognition:
  明确选择:
    模式:
      - "我选择方案?\\s*([A-Z]|\\d+)"
      - "决定?用\\s+(.+)"
      - "就用\\s+(.+)"
      - "采用\\s+(.+)"
    动作: 直接提取方案 ID，进入 SUMMARY

  隐式选择:
    模式:
      - "([\\w]+)更适合"
      - "倾向于([\\w]+)"
      - "([\\w]+)更好"
    动作: 识别倾向方案，要求确认

  约束选择:
    条件: 约束过滤后只剩 1 个可行方案
    动作: 说明约束导致的唯一选择，确认

# === 决策 ID 生成 ===
decision_id_format:
  pattern: "DEC-{YYYYMMDD}-{序列号}"

  示例:
    - DEC-20260205-001 (2026年2月5日第1个决策)
    - DEC-20260205-002 (2026年2月5日第2个决策)

  逻辑:
    - 日期: YYYYMMDD 格式
    - 序列号: 当日第几个决策，从 001 开始
    - 读取 docs/decisions/ 目录，查找当日最大序号

# === 决策记录写入 ===
decision_recording:
  步骤:
    1. 读取决策模板:
       模板路径: aria/skills/brainstorm/templates/decision-template.md

    2. 填充占位符:
       - {ID}: 生成的决策 ID
       - {DATE}: 当前日期 (YYYY-MM-DD)
       - {MODE}: 当前模式
       - {TITLE}: 决策标题
       - {背景}: 从对话中提取的背景信息
       - {约束}: 收集的约束条件表格
       - {方案}: 考虑的方案及对比
       - {选择}: 最终选择的方案
       - {理由}: 决策理由
       - {假设}: 假设条件
       - {风险}: 风险与缓解措施

    3. 写入文件:
       路径: docs/decisions/{mode}-{序列号}.md
       工具: Write
       确认: 写入前展示预览

    4. 更新索引:
       更新 docs/decisions/index.md (如果存在)

# === 决策记录简化格式 ===
minimal_decision_format: |
  ## 决策: {ID} - {TITLE}

  > **日期**: {DATE} | **模式**: {MODE} | **状态**: Active

  ### 背景
  {背景描述}

  ### 约束条件
  | 类型 | 约束 | 影响 |
  |------|------|------|
  {约束行}

  ### 考虑的方案
  | 方案 | 描述 | 评分 | 状态 |
  |------|------|------|------|
  {方案行}

  ### 最终选择
  **方案**: {选择}

  ### 理由
  {理由列表}

  ### 风险与缓解
  | 风险 | 缓解措施 |
  |------|----------|
  {风险行}
```

---

#### 2.6 约束管理系统

```yaml
# === 约束库定义 ===
constraint_library:
  # 业务约束
  business:
    budget:
      type: range
      unit: "$/月"
      hard: true
      default: null
      validator: "检查成本是否在范围内"

    timeline:
      type: range
      unit: "周"
      hard: true
      default: null
      validator: "检查时间是否在范围内"

    compliance:
      type: enum
      values: ["GDPR", "SOC2", "HIPAA", "ISO27001", "数据不出境", "无"]
      hard: true
      default: "无"
      validator: "检查方案是否满足合规要求"

  # 技术约束
  technical:
    deployment:
      type: enum
      values: ["cloud", "on-premise", "hybrid"]
      hard: true
      default: "cloud"
      validator: "检查部署方式支持"

    tech_stack:
      type: list
      hard: false
      default: []
      validator: "检查技术栈兼容性"

    performance:
      type: object
      fields: ["latency", "throughput", "concurrency"]
      hard: false
      default: {}
      validator: "检查性能要求"

    scalability:
      type: enum
      values: ["single-user", "small-team", "enterprise", "internet-scale"]
      hard: false
      default: "small-team"
      validator: "检查扩展性要求"

  # 团队约束
  team:
    skills:
      type: list
      hard: false
      default: []
      validator: "检查团队是否具备所需技能"

    capacity:
      type: range
      unit: "人周"
      hard: false
      default: null
      validator: "检查工作量是否在容量内"

    communication:
      type: enum
      values: ["async", "sync", "hybrid"]
      hard: false
      default: "hybrid"
      validator: "检查协作方式支持"

# === 约束验证流程 ===
constraint_verification:
  步骤:
    1. 收集约束:
       - 从项目配置读取 (.claude/aria.local.md)
       - 从对话中提取
       - 推断隐含约束

    2. 对每个方案验证:
       for option in options:
         for constraint in constraints:
           result = validate(option, constraint)
           if result.violates and constraint.hard:
             option.feasible = false
             option.blocking_reasons.append(result.reason)

    3. 输出验证结果:
       - 列出所有可行方案
       - 说明不可行方案的原因
       - 对可行方案按软约束评分排序

  验证示例:
    输入:
      方案: "使用 OpenAI API"
      约束: {compliance: "数据不出境", hard: true}

    输出:
      feasible: false
      reason: "OpenAI API 需要数据出境，违反'数据不出境'约束"

# === 约束配置示例 ===
# .claude/aria.local.md
project_constraints:
  budget:
    max: 500
    unit: "$/月"

  deployment:
    required: "on-premise"
    reason: "私有机房，不能使用外部服务"

  compliance:
    - "数据不出境"
    - "GDPR"

  team:
    skills: ["Python", "JavaScript"]
    capacity: 40  # 人周/月
```

---

### 阶段 3: 输出生成

#### 3.1 输出映射

```yaml
problem 模式输出:
  主要:
    - docs/decisions/problem-{id}.md
  可选:
    - 触发 spec-drafter (创建 PRD)

requirements 模式输出:
  主要:
    - docs/decisions/requirements-{id}.md
    - docs/requirements/user-stories/US-*.md
  可选:
    - 更新 PRD

technical 模式输出:
  主要:
    - docs/decisions/technical-{id}.md
  可选:
    - openspec/changes/proposal.md (自动填充)
    - 触发 spec-drafter
```

#### 3.2 后续步骤建议

```yaml
after_problem:
  - "[1] 继续头脑风暴，分解 User Stories (requirements 模式)"
  - "[2] 创建 PRD 文档"
  - "[3] 记录决策，稍后继续"

after_requirements:
  - "[1] 为每个 Story 创建 OpenSpec (technical 模式)"
  - "[2] 更新 PRD 文档"
  - "[3] 开始实现 (Phase B)"

after_technical:
  - "[1] 创建完整的 OpenSpec proposal.md"
  - "[2] 继续讨论其他技术点"
  - "[3] 开始实现 (Phase B)"
```

---

## 引导模板系统

### 模板 1: 问题澄清 (problem 模式)

```yaml
开场白:
  "让我们先理解一下你想要解决的问题。"

# === CLARIFY 阶段问题 ===
clarify_questions:
  优先级 1 - 问题本质:
    模板: "你描述的 {模糊术语} 需求背后，核心问题是什么？"
    变体:
      - "能描述一下当前遇到的具体痛点吗？"
      - "这个问题现在是怎么处理的？有什么问题？"
    目标: 识别真需求 vs 伪需求

  优先级 2 - 受益人群:
    模板: "谁会从这个功能中受益？"
    追问:
      - "是内部用户还是外部用户？"
      - "大概有多少用户会使用？"
      - "用户的熟练度如何？"
    目标: 明确目标用户

  优先级 3 - 成功标准:
    模板: "怎么判断这个功能是否成功？"
    追问:
      - "有什么可衡量的指标吗？"
      - "达到什么效果就算解决了问题？"
    目标: 定义可验证的目标

# === EXPLORE 阶段问题 ===
explore_questions:
  优先级 1 - 解决方案方向:
    模板: "针对 {问题}，你有什么初步的想法吗？"
    变体:
      - "有没有参考的类似产品或功能？"
      - "你期望的最佳方案是什么样的？"
    目标: 了解用户期望

  优先级 2 - 约束收集:
    模板: "有什么限制需要考虑？"
    分类:
      - 预算: "有预算限制吗？"
      - 时间: "期望什么时候完成？"
      - 技术: "有技术栈限制吗？"
      - 合规: "有合规要求吗？(如数据安全)"
    目标: 收集所有约束条件

# === CONVERGE 阶段问题 ===
converge_questions:
  优先级 1 - 问题范围确认:
    模板: "所以我们要解决的核心问题是：{问题总结}，对吗？"
    目标: 确认问题边界

  优先级 2 - 优先级判断:
    模板: "在 {约束1} 和 {约束2} 之间，哪个更重要？"
    目标: 明确优先级

# === 收敛信号 ===
completion_criteria:
  必需:
    - 能用一句话描述问题
    - 能明确受益人
    - 有可衡量的成功标准
    - 主要约束已收集

  可选:
    - 有初步方案想法
    - 优先级已明确

  输出示例:
    "
    ╔═══════════════════════════════════════════════════════════╗
    ║                     问题定义                               ║
    ╠═══════════════════════════════════════════════════════════╣
    ║ 核心问题: {问题描述}                                       ║
    ║ 目标用户: {用户描述}                                       ║
    ║ 成功标准: {标准列表}                                       ║
    ╠═══════════════════════════════════════════════════════════╣
    ║ 约束条件:                                                  ║
    ║ - {约束1}: {描述}                                         ║
    ║ - {约束2}: {描述}                                         ║
    ╚═══════════════════════════════════════════════════════════╝
    "
```

---

### 模板 2: 需求分解 (requirements 模式)

```yaml
开场白:
  "让我们把这个需求分解成可实现的 User Stories。"

# === CLARIFY 阶段问题 ===
clarify_questions:
  优先级 1 - 功能范围:
    模板: "PRD 中提到的 {功能术语} 具体包含哪些内容？"
    追问:
      - "这个功能的边界在哪里？"
      - "哪些是不在范围内的？"
    目标: 明确功能边界

  优先级 2 - 用户角色:
    模板: "谁会使用这个功能？"
    追问:
      - "有不同类型的用户吗？"
      - "不同用户有不同权限吗？"
    目标: 识别用户角色

# === EXPLORE 阶段问题 ===
explore_questions:
  优先级 1 - 功能拆解:
    模板: "{功能} 可以分解为哪些子功能？"
    引导:
      - "按用户操作流程分解？"
      - "按功能模块分解？"
    目标: 生成功能列表

  优先级 2 - 用户场景:
    模板: "用户在什么情况下会使用 {子功能}？"
    引导:
      - "描述一个典型的使用场景"
      - "用户的输入是什么？期望的输出是什么？"
    目标: 生成用户场景

  优先级 3 - 优先级:
    模板: "如果资源有限，哪些是必须做的？"
    引导:
      - "哪些是核心功能？"
      - "哪些可以后续迭代？"
    目标: 确定优先级

  优先级 4 - 依赖关系:
    模板: "这些功能之间有依赖吗？"
    引导:
      - "A 功能依赖 B 功能吗？"
      - "可以按什么顺序实现？"
    目标: 识别依赖关系

# === CONVERGE 阶段问题 ===
converge_questions:
  优先级 1 - Story 确认:
    模板: "所以 User Story {N} 是：{故事描述}，对吗？"
    格式: "作为 {角色}，我想要 {功能}，以便 {价值}"
    目标: 确认每个 Story

  优先级 2 - 验收标准:
    模板: "怎么判断 {Story} 已经完成？"
    引导:
      - "有什么具体的验收条件？"
      - "可以怎么测试？"
    目标: 生成验收标准

# === 收敛信号 ===
completion_criteria:
  必需:
    - 每个 Story 符合 "作为...我想要...以便..." 格式
    - 有明确的验收标准
    - 优先级已确定
    - 依赖关系已标注

  可选:
    - 有估算点数
    - 有初步任务分解

  User Story 模板:
    "
    ## US-{序号}: {标题}

    > **优先级**: P{0-3} | **状态**: Ready | **点数**: {估算}

    **描述**:
    作为 {角色}，我想要 {功能}，以便 {价值}。

    **验收标准**:
    - [ ] {标准1}
    - [ ] {标准2}
    - [ ] {标准3}

    **依赖**: {依赖的 Story ID}
    "
```

---

### 模板 3: 方案对比 (technical 模式)

```yaml
开场白:
  "让我们讨论一下技术实现方案。"

# === CLARIFY 阶段问题 ===
clarify_questions:
  优先级 1 - 技术需求:
    模板: "从技术角度看，{功能} 的核心需求是什么？"
    追问:
      - "有性能要求吗？(延迟/吞吐量)"
      - "有扩展性要求吗？"
      - "有可用性要求吗？"
    目标: 明确技术指标

  优先级 2 - 现状评估:
    模板: "当前系统在这方面是怎么实现的？"
    追问:
      - "现有架构能支持吗？"
      - "需要什么改动？"
    目标: 评估技术债和迁移成本

# === EXPLORE 阶段问题 ===
explore_questions:
  优先级 1 - 方案列举:
    模板: "实现 {功能} 有哪些技术选项？"
    引导:
      - "有哪些成熟方案可以参考？"
      - "开源方案 vs 自研？"
      - "有新的技术可以尝试吗？"
    目标: 列出至少 3 个方案

  优先级 2 - 约束检查:
    模板: "根据 {约束}，哪些方案不可行？"
    约束映射:
      预算限制:
        - 排除: 昂贵的商业方案
        - 偏好: 开源/自建

      数据不出境:
        - 排除: 需要境外服务的方案
        - 偏好: 私有化部署

      团队技能:
        - 排除: 团队不熟悉的技术
        - 偏好: 团队熟悉的栈

      时间限制:
        - 排除: 学习成本高的方案
        - 偏好: 成熟/简单方案

    目标: 过滤不可行方案

  优先级 3 - 方案细化:
    模板: "说说 {方案} 的具体实现方式？"
    追问:
      - "需要引入哪些新组件？"
      - "数据流是怎样的？"
      - "有什么技术难点？"
    目标: 理解方案细节

# === CONVERGE 阶段问题 ===
converge_questions:
  优先级 1 - 多维度对比:
    模板: "在以下维度上，对比 {方案A} 和 {方案B}："
    维度:
      - 实现复杂度: "哪个更容易实现？"
      - 性能: "哪个性能更好？"
      - 维护成本: "哪个更容易维护？"
      - 扩展性: "哪个更容易扩展？"
      - 风险: "哪个风险更低？"
    目标: 生成对比表

  优先级 2 - 风险评估:
    模板: "每个方案的主要风险是什么？"
    引导:
      - "技术风险：有不成熟的组件吗？"
      - "业务风险：会影响现有功能吗？"
      - "团队风险：团队有能力实现吗？"
    目标: 识别并评估风险

  优先级 3 - 决策引导:
    模板: "综合考虑，你倾向哪个方案？"
    引导:
      - "哪个约束最重要？"
      - "短期 vs 长期，哪个更重要？"
      - "有折中方案吗？"
    目标: 做出最终选择

# === 收敛信号 ===
completion_criteria:
  必需:
    - 至少 2 个方案已详细讨论
    - 不可行方案已排除并说明原因
    - 可行方案有多维度对比
    - 风险已识别
    - 做出明确选择

  方案对比表模板:
    "
    | 维度 | {方案A} | {方案B} | {方案C} |
    |------|---------|---------|---------|
    | 实现复杂度 | {低/中/高} | {低/中/高} | {低/中/高} |
    | 性能 | {描述} | {描述} | {描述} |
    | 维护成本 | {描述} | {描述} | {描述} |
    | 满足约束 | {Yes/No} | {Yes/No} | {Yes/No} |
    | 风险 | {描述} | {描述} | {描述} |
    | 推荐 | ⭐ | | |
    "

  决策总结模板:
    "
    ╔═══════════════════════════════════════════════════════════╗
    ║                     技术方案决策                           ║
    ╠═══════════════════════════════════════════════════════════╣
    ║ 选择: {方案名称}                                           ║
    ╠═══════════════════════════════════════════════════════════╣
    ║ 理由:                                                      ║
    ║ 1. {理由1}                                                ║
    ║ 2. {理由2}                                                ║
    ║ 3. {理由3}                                                ║
    ╠═══════════════════════════════════════════════════════════╣
    ║ 假设条件:                                                  ║
    ║ - {假设1}                                                 ║
    ║ - {假设2}                                                 ║
    ╠═══════════════════════════════════════════════════════════╣
    ║ 主要风险与缓解:                                            ║
    ║ - {风险1} → {缓解措施}                                    ║
    ║ - {风险2} → {缓解措施}                                    ║
    ╚═══════════════════════════════════════════════════════════╝
    "
```

---

### 通用追问技巧

```yaml
# 当用户回答模糊时
clarification_prompts:
  - "能举个例子吗？"
  - "具体是指？"
  - "你说的 {术语} 可以详细解释一下吗？"
  - "有没有具体的场景可以说明？"

# 当对话停滞时
conversation_prompts:
  - "还有其他需要考虑的吗？"
  - "这个方案有什么潜在问题？"
  - "如果是你，你会怎么选？"
  - "我们漏掉了什么吗？"

# 当需要深入时
deepening_prompts:
  - "为什么你觉得 {方案} 更好？"
  - "{方案} 有什么劣势吗？"
  - "如果我们放宽 {约束}，选择会变化吗？"
  - "从 {另一个角度} 来看，有什么不同？"

# 当准备收敛时
convergence_prompts:
  - "综合来看，哪个方案最合适？"
  - "有最佳选择吗？"
  - "我们可以做决定了吗？"
  - "还有什么顾虑吗？"
```

---

## 约束管理

### 约束分类

```yaml
business_constraints:
  - budget: 预算限制
  - timeline: 时间限制
  - compliance: 合规要求 (GDPR, 数据安全)
  - resources: 人力/资源限制

technical_constraints:
  - architecture: 架构约束 (微服务/单体)
  - tech_stack: 技术栈限制
  - performance: 性能要求 (延迟/吞吐)
  - scalability: 扩展性要求
  - compatibility: 兼容性要求

team_constraints:
  - skills: 团队技能
  - preferences: 团队偏好
  - capacity: 可用工时
  - communication: 协作方式
```

### 约束验证流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         约束验证流程                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 收集约束                                                             │
│     ├── 从项目配置读取默认约束                                           │
│     └── 对话中收集特定约束                                               │
│                                                                         │
│  2. 方案过滤                                                             │
│     ├── 检查每个方案是否违反硬约束                                       │
│     └── 标记不可行方案                                                   │
│                                                                         │
│  3. 风险评估                                                             │
│     ├── 评估软约束的影响程度                                             │
│     └── 提出缓解措施                                                     │
│                                                                         │
│  4. 记录决策                                                             │
│     ├── 记录约束条件                                                     │
│     └── 记录约束导致的选择                                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 与其他 Skills 的集成

### 集成点 1: state-scanner

```yaml
触发条件:
  - 检测到模糊需求意图
  - 变更复杂度 >= Level 2
  - 无对应 OpenSpec

推荐输出:
  "发现新功能想法，建议先进行头脑风暴澄清需求"
  选项:
    [1] 开始头脑风暴
    [2] 直接创建 OpenSpec
    [3] 跳过，稍后处理
```

### 集成点 2: spec-drafter

```yaml
输入:
  - 来自 brainstorm 的决策记录
  - 约束条件
  - 方案选择

行为:
  - 自动填充 proposal.md 的背景部分
  - 预填充技术方案
  - 引用决策 ID

输出示例:
  ```markdown
  # Proposal: AI 客服功能

  > **决策来源**: [DEC-001](../../decisions/technical-001.md)

  ## 背景
  (来自 problem-brainstorm 的问题定义)

  ## 技术方案
  (来自 technical-brainstorm 的方案选择)
  ```
```

### 集成点 3: requirements-validator

```yaml
验证内容:
  - User Story 与决策记录的一致性
  - 约束条件是否被违反
  - 优先级与决策逻辑的一致性

错误示例:
  "❌ US-003 描述使用了 OpenAI API，但 DEC-001 决策排除数据出境方案"
```

### 集成点 4: task-planner

```yaml
输入增强:
  - 来自 technical-brainstorm 的技术方案
  - 更准确的任务分解
  - 更好的依赖关系识别

输出改进:
  - 任务关联决策 ID
  - 风险任务标记
```

---

## 配置选项

### 项目级配置

```yaml
# .claude/aria.local.md

brainstorm:
  # 是否启用
  enabled: true

  # 触发模式
  trigger_mode: auto  # auto | always | manual

  # 自动触发阈值
  auto_trigger:
    fuzziness_threshold: 0.6  # 模糊度超过此值自动触发
    complexity_threshold: Level2  # Level2+ 自动触发

  # 对话配置
  conversation:
    max_rounds:
      problem: 10
      requirements: 15
      technical: 8

    convergence_threshold: 0.7  # 共识度超过此值可以收敛

  # 输出配置
  output:
    save_decisions: true
    save_conversation: false  # 是否保存完整对话
    decision_dir: docs/decisions/
    auto_sync_openspec: true

  # 默认约束
  default_constraints:
    budget: "$1000/月"
    compliance: ["GDPR", "数据不出境"]
```

### 会话级配置

```yaml
# 通过参数传递

/brainstorm problem "添加AI功能"
  --fuzziness high
  --max-rounds 15
  --constraints budget:$500

/brainstorm technical
  --mode interactive
  --auto-converge false
```

---

## 使用示例

### 示例 1: Problem 模式完整对话

```yaml
用户: /brainstorm problem "我想给应用加个AI功能"

AI: 让我们先理解一下你想要解决的问题。

     [问题澄清]
     1. 你说的 AI 功能具体指什么？
      - a) 智能推荐
      - b) 自动补全
      - c) 对话助手
      - d) 其他

用户: c，我想做一个智能客服

AI: 明白了，智能客服助手。让我们继续澄清：

     2. 这个客服要解决什么问题？
      - 当前有什么痛点？
      - 期望达到什么效果？

用户: 现在客服经常不在，用户问题得不到及时回答。
     我希望用户能随时得到帮助。

AI: [记录问题核心: 及时性]

     3. 关于回答质量:
      - 需要多"智能"？
      - 简单 FAQ 自动回答够吗？
      - 还是需要理解复杂问题？

用户: 至少能回答产品相关的问题，复杂问题再转人工。

AI: [记录约束: 产品知识库 + 人工兜底]

     4. 有什么限制条件吗？
      - 预算范围？
      - 时间要求？
      - 合规要求？

用户: 预算有限，最好每月不超过500块。
     数据不能出私有机房，有合规要求。

AI: [记录约束: 预算<$500 + 私有化部署]

     让我总结一下我们的讨论:

     ╔═══════════════════════════════════════════════════════════╗
     ║                     问题定义                               ║
     ╠═══════════════════════════════════════════════════════════╣
     ║ 核心问题: 用户咨询得不到及时响应                           ║
     ║ 目标用户: 产品使用用户                                     ║
     ║ 成功标准: 24/7 可用，产品问题自动回答率 > 80%              ║
     ╠═══════════════════════════════════════════════════════════╣
     ║ 约束条件:                                                  ║
     ║ - 预算: < $500/月                                         ║
     ║ - 部署: 私有化，数据不出境                                 ║
     ║ - 功能: 产品知识库问答，复杂问题转人工                     ║
     ╚═══════════════════════════════════════════════════════════╝

     建议: 创建 PRD 来详细规划这个功能。

     下一步:
     [1] 继续头脑风暴，分解 User Stories
     [2] 创建 PRD 文档
     [3] 记录决策，稍后继续

用户: 1

AI: [切换到 requirements 模式]
     让我们把智能客服分解成具体的 User Stories...
```

### 示例 2: Technical 模式快速对话

```yaml
用户: /brainstorm technical "RAG 实现，选择向量数据库"

AI: [加载上下文: US-001 AI 客服基础问答]

     已知约束:
     - 预算: < $500/月
     - 部署: 私有化

     可行的向量存储选项:

     | 方案 | 类型 | 月成本 | 优点 | 缺点 |
     |------|------|--------|------|------|
     | A | Pinecone | $70 | 易用 | 需外网 |
     | B | Weaviate | 自建 | 免费 | 运维成本 |
     | C | FAISS | 嵌入 | $0 | 功能有限 |
     | D | Milvus | 自建 | 免费 | 复杂度高 |

     考虑到[数据不出境]约束，排除 A。

     在 B/C/D 之间，你的数据量级大概是多少？

用户: 文档大概 1 万条，预期月增长 1000 条

AI: 这个规模下，C(FAISS) 最合适:
     - 完全免费，满足预算要求
     - 1万条文档性能良好
     - Python 生态支持完善

     但要考虑:
     - 持续增长需要定期评估迁移时机
     - 需要自己实现增量更新逻辑

     是否选择 FAISS？如果需要更强大的功能，
     我建议 Milvus 作为备选。

用户: 就用 FAISS 吧

AI: [记录决策 DEC-002]

     决策记录:
     - 方案: FAISS 向量存储
     - 理由: 满足成本 + 性能要求
     - 假设: 文档量 < 5 万条时可行
     - 风险: 增量更新需自行实现
     - 缓解: 预留迁移接口，定期评估

     已自动更新 OpenSpec proposal.md。

     下一步:
     [1] 继续讨论嵌入模型选择
     [2] 生成完整技术方案
     [3] 结束头脑风暴

用户: 1

AI: [继续对话]
```

---

## 输出文件规范

### 决策日志结构

```
docs/decisions/
├── .template.md           # 决策记录模板
├── problem-001.md         # 问题空间探索决策
├── requirements-001.md    # 需求分解决策
└── technical-001.md       # 技术方案决策
```

### 文件命名

```yaml
格式: {mode}-{sequence}.md

示例:
  problem-001.md  → 问题空间探索，第 1 个决策
  tech-003.md    → 技术方案，第 3 个决策
```

### 最小决策模板

```markdown
# 决策: DEC-{id} - {title}

> **日期**: {{date}}
> **模式**: {{problem|requirements|technical}}
> **状态**: Active | Archived | Superseded

## 背景

{{决策的背景和上下文}}

## 约束条件

| 类型 | 约束 | 影响 |
|------|------|------|
| | | |

## 考虑的方案

### 方案 A: {{name}}

**描述**:
**优点**:
**缺点**:
**评分**:

### 方案 B: {{name}}

...

## 最终选择

**方案**: {{selected}}

## 理由

{{为什么选择这个方案}}

## 假设条件

{{决策基于的假设}}

## 风险与缓解

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| | | | |

## 变更历史

| 日期 | 变更 | 原因 |
|------|------|------|
```

---

## 检查清单

### 使用前

- [ ] 有需要澄清的需求或想法
- [ ] 愿意进行多轮对话
- [ ] 准备记录决策

### 使用中

- [ ] 核心问题已澄清
- [ ] 约束条件已收集
- [ ] 方案已充分讨论
- [ ] 决策理由已记录

### 使用后

- [ ] 决策日志已创建
- [ ] 后续步骤已明确
- [ ] 相关文档已同步

---

## 错误处理与边界情况

### 异常处理策略

```yaml
# === 对话无法收敛 ===
error: cannot_converge
  检测条件:
    - 达到最大轮次 (round >= max_rounds)
    - 共识度 < 0.5
    - 可行方案 > 1 个

  处理步骤:
    1. 展示当前状态:
       - "我们讨论了 {N} 轮，还有 {M} 个可行方案。"
       - 展示方案对比表

    2. 提供选项:
       - "[1] 强制选择当前最优方案"
       - "[2] 降低期望，放宽约束"
       - "[3] 分解问题，分别处理"
       - "[4] 暂停讨论，稍后继续"

    3. 如选择强制选择:
       - 选择评分最高的方案
       - 在决策记录中标注 "强制收敛"
       - 说明原因和建议

  输出示例:
    "
    ╔═══════════════════════════════════════════════════════════╗
    ║                   对话收敛困难                             ║
    ╠═══════════════════════════════════════════════════════════╣
    ║ 当前状态: 已讨论 {N} 轮，共识度 {C}%                      ║
    ╠═══════════════════════════════════════════════════════════╣
    ║ 可行方案对比:                                             ║
    ║ {方案对比表}                                              ║
    ╠═══════════════════════════════════════════════════════════╣
    ║ 建议:                                                      ║
    ║ 1. 如果时间紧，选择 {最优方案}                            ║
    ║ 2. 如果追求完美，建议先做 {MVP} 再迭代                     ║
    ╚═══════════════════════════════════════════════════════════╝
    "

# === 约束冲突 ===
error: constraint_conflict
  检测条件:
    - 所有方案都违反至少一个硬约束
    - 两个硬约束互相矛盾

  处理步骤:
    1. 识别冲突约束:
       - "检测到约束冲突:"
       - 列出冲突的约束及其原因

    2. 解释影响:
       - "在当前约束下，没有可行方案"
       - 说明哪些约束导致哪些方案不可行

    3. 提供选项:
       - "[1] 放宽约束 {X}"
       - "[2] 降低约束 {Y} 的优先级"
       - "[3] 寻找新的方案"
       - "[4] 分阶段实现，先满足部分约束"

  输出示例:
    "
    ⚠️ 约束冲突检测

    冲突约束:
    - 约束 A: 预算 < $500/月
    - 约束 B: 使用企业级托管服务

    冲突原因: 企业级托管服务的最低费用为 $800/月

    建议:
    [1] 放宽预算约束到 $1000/月
    [2] 使用开源自建方案代替托管服务
    [3] 混合方案：核心功能托管 + 其他自建
    "

# === 无可行方案 ===
error: no_feasible_solution
  检测条件:
    - 所有方案都违反硬约束
    - feasible_options == 0

  处理步骤:
    1. 说明情况:
       - "在当前约束下，没有可行方案"

    2. 展示被排除的方案及原因:
       | 方案 | 排除原因 | 违反约束 |
       |------|----------|----------|
       | A | 成本超预算 | budget: <$500 |
       | B | 需数据出境 | compliance: 数据不出境 |

    3. 提供选项:
       - "[1] 放宽约束 {约束列表}"
       - "[2] 寻找新的方案"
       - "[3] 分阶段实现，逐步满足约束"

    4. 生成新方案建议:
       - 基于约束，提出简化方案
       - 建议分阶段实现路径

# === 用户放弃/中断 ===
error: user_abort
  检测条件:
    - 用户输入: "算了"、"不用了"、"暂停"
    - 用户长时间无响应

  处理步骤:
    1. 确认意图:
       - "确定要暂停讨论吗？"

    2. 保存当前进度:
       - 保存已收集的信息
       - 保存已讨论的方案
       - 生成 "草稿" 状态的决策记录

    3. 提供恢复选项:
       - "当前讨论已保存到 {path}"
       - "使用 /brainstorm continue 可继续讨论"

  草稿格式:
    "
    # 头脑风暴草稿 - {标题}

    > 状态: 草稿 | 创建时间: {timestamp} | 位置: {path}

    ## 已收集信息
    - 问题定义: {问题描述}
    - 约束条件: {约束列表}
    - 已讨论方案: {方案列表}

    ## 待讨论
    - {待讨论项1}
    - {待讨论项2}

    ## 恢复方式
    使用 `/brainstorm continue {id}` 继续讨论
    "

# === 上下文不足 ===
error: insufficient_context
  检测条件:
    - 无法从用户输入提取关键信息
    - 模糊度 > 0.8 且无法通过澄清降低

  处理步骤:
    1. 提供示例:
       - "让我给你一个参考示例..."

    2. 分解问题:
       - "这个问题比较大，我们可以从某个方面开始"
       - 提供 2-3 个切入角度

    3. 建议准备:
       - "建议先准备以下信息再开始讨论:"
       - 列出需要准备的内容
```

---

### 边界情况处理

```yaml
# === 第一次使用 ===
scenario: first_time_user
  检测: docs/decisions/ 目录不存在
  动作:
    1. 创建目录
    2. 简化开场白
    3. 提供更多引导

# === 跨模式切换 ===
scenario: mode_switch
  触发: 用户明确要求切换模式
  动作:
    1. 保存当前模式的进度
    2. 生成临时决策记录
    3. 切换到新模式
    4. 加载相关上下文

  示例:
    用户: "先讨论技术方案"
    AI: "切换到 technical 模式，基于之前的问题定义..."

# === 决策撤销 ===
scenario: decision_reversal
  触发: 用户想撤销之前的决策
  动作:
    1. 检查决策的可撤销性
    2. 如果可撤销:
       - 标记原决策为 "Superseded"
       - 记录撤销原因
       - 重新讨论
    3. 如果不可撤销:
       - 说明影响
       - 建议新方案
```

---

### 错误处理流程图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        错误检测与处理                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  检测点                    错误类型                   处理动作            │
│  ─────                  ─────────                  ────────             │
│                                                                         │
│  每轮结束              ┌──────────────┐          保存进度               │
│  └─→ 共识度 < 0.5   ──→│ 无法收敛     │─────────→ 提供选项             │
│       轮次接近上限      └──────────────┘          建议方案               │
│                                                                         │
│  约束验证              ┌──────────────┐          识别冲突               │
│  └─→ 无可行方案      ──→│ 约束冲突     │─────────→ 放宽约束             │
│       方案全被排除      └──────────────┘          寻找新方案             │
│                                                                         │
│  用户输入              ┌──────────────┐          确认意图               │
│  └─→ "算了" / "暂停" ──→│ 用户放弃     │─────────→ 保存草稿             │
│                         └──────────────┘          提供恢复方式           │
│                                                                         │
│  上下文检查            ┌──────────────┐          提供示例               │
│  └─→ 信息不足        ──→│ 上下文不足   │─────────→ 分解问题             │
│       模糊度 > 0.8      └──────────────┘          建议准备               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 相关文档

- [SKILL_DESIGN.md](./SKILL_DESIGN.md) - 设计文档
- [state-scanner](../state-scanner/SKILL.md) - 状态扫描入口
- [spec-drafter](../spec-drafter/SKILL.md) - 规范创建
- [requirements-validator](../requirements-validator/SKILL.md) - 需求验证

---

**最后更新**: 2026-02-05
**Skill版本**: 1.1.0 (Phase 1 核心框架已实现)
